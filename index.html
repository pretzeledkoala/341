<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chutes and Ladders</title>


  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #f5f5f5;
      padding: 20px;
      margin: 0;
    }
    
    h1 {
      color: #333;
      margin-bottom: 10px;
      text-align: center;
    }
    
    .tab-container {
      width: 100%;
      max-width: 800px;
      margin-bottom: 20px;
    }
    
    .tabs {
      display: flex;
      background-color: white;
      border-radius: 8px 8px 0 0;
      overflow: hidden;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .tab {
      flex: 1;
      padding: 15px;
      text-align: center;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.3s ease;
      border-bottom: 3px solid transparent;
    }
    
    .tab.active {
      background-color: #4CAF50;
      color: white;
      border-bottom: 3px solid #2e7d32;
    }
    
    .tab:hover:not(.active) {
      background-color: #e8f5e9;
    }
    
    .tab-content {
      display: none;
      background-color: white;
      padding: 20px;
      border-radius: 0 0 8px 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .tab-content.active {
      display: block;
    }
    
    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      margin-bottom: 20px;
    }
    
    .board-container {
      position: relative;
      width: 500px;
      height: 500px;
      background-color: white;
      border: 2px solid #333;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    .board {
      display: grid;
      grid-template-columns: repeat(10, 1fr);
      grid-template-rows: repeat(10, 1fr);
      width: 100%;
      height: 100%;
    }
    
    .cell {
      border: 1px solid #ccc;
      display: flex;
      justify-content: center;
      align-items: center;
      font-weight: bold;
      position: relative;
      user-select: none;
    }
    
    /* colors!! */
    .red { background-color: #ff6b6b; }
    .blue { background-color: #70a1ff; }
    .green { background-color: #7bed9f; }
    .yellow { background-color: #ffe066; }
    .white { background-color: #ffffff; }
    
    .player {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background-color: #333;
      position: absolute;
      z-index: 10;
      transition: all 0.5s ease;
    }
    
    .controls {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      width: 100%;
      max-width: 300px;
    }
    
    .dice {
      width: 60px;
      height: 60px;
      background-color: white;
      border: 2px solid #333;
      border-radius: 8px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 10px;
    }
    
    button {
      padding: 10px 20px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 16px;
      cursor: pointer;
      transition: background-color 0.3s;
      width: 100%;
      margin-bottom: 5px;
    }
    
    button:hover {
      background-color: #45a049;
    }
    
    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    
    .game-info {
      margin-top: 10px;
      font-size: 18px;
      text-align: center;
    }
    
    .modal {
      display: none;
      position: fixed;
      z-index: 100;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      justify-content: center;
      align-items: center;
    }
    
    .modal-content {
      background-color: white;
      padding: 30px;
      border-radius: 10px;
      text-align: center;
      max-width: 400px;
    }
    
    .modal h2 {
      color: #4CAF50;
      margin-bottom: 20px;
    }
    
    .chute, .ladder {
      position: absolute;
      z-index: 5;
      pointer-events: none;
    }

    .edit-mode-controls {
      display: flex;
      flex-direction: column;
      width: 100%;
      margin-top: 15px;
      gap: 10px;
    }
    
    .edit-button-group {
      display: flex;
      gap: 5px;
    }
    
    .edit-button-group button {
      flex: 1;
    }
    
    .transition-list {
      max-height: 150px;
      overflow-y: auto;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 10px;
      margin-top: 10px;
    }
    
    .transition-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
      padding: 5px;
      background-color: #f5f5f5;
      border-radius: 4px;
    }
    
    .transition-item:hover {
      background-color: #e0e0e0;
    }
    
    .transition-item button {
      padding: 2px 8px;
      margin: 0;
      width: auto;
      background-color: #ff6b6b;
    }
    
    /* Statistics styles */
    .statistics {
      width: 100%;
      max-width: 800px;
      background-color: white;
      padding: 20px;
      border-radius: 8px;
    }
    
    .stats-header {
      text-align: center;
      margin-bottom: 20px;
    }
    
    .results {
      margin: 20px 0;
      padding: 0 20px;
    }
    
    .chart {
      display: flex;
      justify-content: center;
      margin-top: 40px;
      width: 100%;
      height: 250px;
    }
    
    .custom-transitions-section {
      margin-top: 30px;
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 5px;
      background-color: #f9f9f9;
    }
    
    .export-buttons {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }
    
    .export-buttons button {
      flex: 1;
    }
    
    .import-export-section {
      margin-top: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .import-export-section textarea {
      width: 100%;
      height: 100px;
      resize: vertical;
      font-family: monospace;
      font-size: 12px;
    }
    
    /* Responsive styles */
    @media (max-width: 600px) {
      .board-container {
        width: 90vw;
        height: 90vw;
      }
      
      .tabs {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <h1>Chutes and Ladders</h1>
  
  <div class="tab-container">
    <div class="tabs">
      <div class="tab active" data-tab="game">Play Game</div>
      <div class="tab" data-tab="edit">Edit Board</div>
      <div class="tab" data-tab="stats">Statistics</div>
    </div>
    
    <div id="game-tab" class="tab-content active">
      <div class="game-container">
        <div class="board-container">
          <div class="board" id="board"></div>
          <div id="player" class="player"></div>
        </div>
        
        <div class="controls">
          <div class="dice" id="dice">?</div>
          <button id="rollButton">Roll Dice</button>
          <div class="game-info" id="gameInfo">Start at position 0. Roll to begin!</div>
        </div>
      </div>
    </div>
    
    <div id="edit-tab" class="tab-content">
      <div class="game-container">
        <div class="board-container">
          <div class="board" id="edit-board"></div>
        </div>
        
        <!-- <div class="controls">
          <h3>Edit Chutes and Ladders</h3>
          <div id="edit-info">Click on two cells to create a connection</div> -->

          <!-- Add this HTML for the modal form after the win modal -->
<div class="modal" id="transitionModal">
  <div class="modal-content">
    <h2 id="transition-modal-title">Add Ladder</h2>
    <div style="margin: 20px 0;">
      <div style="margin-bottom: 15px;">
        <label for="start-position">Start Position:</label>
        <input type="number" id="start-position" min="1" max="99" style="width: 60px; padding: 5px;">
      </div>
      <div>
        <label for="end-position">End Position:</label>
        <input type="number" id="end-position" min="1" max="99" style="width: 60px; padding: 5px;">
      </div>
    </div>
    <div style="display: flex; gap: 10px;">
      <button id="save-transition-button">Save</button>
      <button id="cancel-transition-button">Cancel</button>
    </div>
  </div>
</div>

<!-- // Modify the edit-mode-controls div in the edit-tab section by replacing the edit-button-group with this: -->
<!-- <div class="edit-button-group">
  <button id="add-ladder-button">Add Ladder</button>
  <button id="add-chute-button">Add Chute</button>
</div> -->
          
          <div class="edit-mode-controls">
            <div class="edit-button-group">
              <button id="add-ladder-button" class="active">Add Ladder</button>
              <button id="add-chute-button">Add Chute</button>
            </div>
            <!-- <button id="reset-selection-button">Reset Selection</button> -->
            <button id="reset-board-button">Reset to Default</button>
            
            <div class="transition-list" id="transition-list">
              <!-- Transitions will be listed here -->
            </div>
            
            <div class="import-export-section">
              <h4>Import/Export</h4>
              <textarea id="import-export-json" placeholder="Paste JSON here to import or copy to export"></textarea>
              <div class="export-buttons">
                <button id="import-button">Import</button>
                <button id="export-button">Export</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <div id="stats-tab" class="tab-content">
      <div class="statistics">
        <h2 class="stats-header">Game Statistics</h2>
        <div class="results">
          <p id="expected-moves">Expected number of moves: --</p>
          <p id="median-moves">Median number of moves: --</p>
          <p id="std-dev-moves">Standard deviation of moves: --</p>
        </div>
        <div class="chart">
          <canvas id="moves-histogram" width="700" height="250"></canvas>
        </div>
        <div style="text-align: center; margin-top: 20px;">
          <button id="runSimulationButton">Run 10,000 Simulations</button>
        </div>
        
        <div class="custom-transitions-section">
          <h3>Current Board Configuration</h3>
          <p id="transitions-count">Number of ladders: 0, Number of chutes: 0</p>
          <p id="transition-stats">Average ladder climb: 0, Average chute fall: 0</p>
        </div>
      </div>
    </div>
  </div>
  
  <div class="modal" id="winModal">
    <div class="modal-content">
      <h2>Congratulations!</h2>
      <p>You reached square 100! You won the game!</p>
      <button id="newGameButton">Play Again</button>
    </div>
  </div>

  <script>
    // Replace the handleCellClick function with this new version
function handleCellClick(cellNumber) {
  // This function is no longer needed for cell selection since we're using the modal
  const cell = document.getElementById(`edit-cell-${cellNumber}`);
  cell.classList.add('highlight');
  
  setTimeout(() => {
    cell.classList.remove('highlight');
  }, 500);
}

// Add these functions to handle the modal interface
function showTransitionModal(type) {
  const modal = document.getElementById('transitionModal');
  const title = document.getElementById('transition-modal-title');
  
  // Set modal title based on type
  title.textContent = type === 'ladder' ? 'Add Ladder' : 'Add Chute';
  
  // Clear previous values
  document.getElementById('start-position').value = '';
  document.getElementById('end-position').value = '';
  
  // Show modal
  modal.style.display = 'flex';
}

function saveTransition() {
  const startPos = parseInt(document.getElementById('start-position').value);
  const endPos = parseInt(document.getElementById('end-position').value);
  
  // Validate inputs
  if (isNaN(startPos) || isNaN(endPos) || startPos < 1 || startPos > 99 || endPos < 1 || endPos > 99) {
    alert('Please enter valid positions (1-99)');
    return;
  }
  
  if (startPos === endPos) {
    alert("Start and end positions cannot be the same");
    return;
  }
  
  const modalTitle = document.getElementById('transition-modal-title').textContent;
  const type = modalTitle.includes('Ladder') ? 'ladder' : 'chute';
  
  // For ladders, end should be higher than start
  if (type === 'ladder' && endPos <= startPos) {
    alert('For ladders, the end position must be higher than the start position');
    return;
  }
  
  // For chutes, start should be higher than end
  if (type === 'chute' && startPos <= endPos) {
    alert('For chutes, the start position must be higher than the end position');
    return;
  }
  
  // Check if we already have a transition from start position
  if (transitions[startPos] !== undefined) {
    if (!confirm(`Position ${startPos} already has a transition. Replace it?`)) {
      return;
    }
    delete transitions[startPos];
  }
  
  // Add the transition
  transitions[startPos] = endPos;
  
  // Redraw all chutes and ladders
  drawChutesAndLadders('edit-board');
  updateTransitionList();
  updateTransitionStats();
  
  // Hide modal
  document.getElementById('transitionModal').style.display = 'none';
}

// Replace the event listeners for add-ladder-button and add-chute-button
// in the setupEventListeners function with these:
document.getElementById('add-ladder-button').addEventListener('click', () => {
  showTransitionModal('ladder');
});

document.getElementById('add-chute-button').addEventListener('click', () => {
  showTransitionModal('chute');
});

// Add these event listeners to the setupEventListeners function
document.getElementById('save-transition-button').addEventListener('click', saveTransition);
document.getElementById('cancel-transition-button').addEventListener('click', () => {
  document.getElementById('transitionModal').style.display = 'none';
});
  </script>

  <script>
    // Game state
    let currentPosition = 0;
    let isMoving = false;
    
    // Edit mode state
    let editMode = "ladder"; // "ladder" or "chute"
    let selectedCells = [];
    
    // Define the chutes and ladders (transitions)
    let transitions = {
      "1": 38, "4": 14, "9": 31, "17": 7, "21": 42, "28": 84, "51": 67, "71": 91,
      "54": 34, "62": 19, "64": 60, "80": 99,
      "87": 24, "93": 73, "95": 75, "98": 79
    };
    
    // Keep a copy of the default transitions
    const defaultTransitions = JSON.parse(JSON.stringify(transitions));
    
    // Tab functionality
    function setupTabs() {
      const tabs = document.querySelectorAll('.tab');
      tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          // Remove active class from all tabs and content
          document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
          
          // Add active class to clicked tab
          tab.classList.add('active');
          
          // Show corresponding content
          const tabId = tab.getAttribute('data-tab');
          document.getElementById(`${tabId}-tab`).classList.add('active');
          
          // If switching to edit tab, refresh the edit board
          if (tabId === 'edit') {
            createEditBoard();
            updateTransitionList();
          } else if (tabId === 'stats') {
            updateTransitionStats();
          } else if (tabId === 'game') {
            // Refresh the game board to apply any changes
            createBoard();
            updatePlayerPosition(currentPosition);
          }
        });
      });
    }
    
    // Generate the board
    function createBoard() {
      const board = document.getElementById('board');
      board.innerHTML = '';
      
      // Create a 10x10 grid with numbers 1 to 100, starting from bottom-left
      let cellNumber = 1;
      for (let row = 9; row >= 0; row--) { // Start from row 9 (bottom) to row 0 (top)
        const rowStart = row * 10 + 1;
        const rowEnd = (row + 1) * 10;
        
        for (let col = 0; col < 10; col++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          
          // Assign cell number based on row (snake pattern)
          if (row % 2 === 0) { // Even rows (left to right)
            cellNumber = rowStart + col;
          } else { // Odd rows (right to left)
            cellNumber = rowEnd - col;
          }
          
          // Set cell color based on the board image
          if ((row + col) % 4 === 0) {
            cell.classList.add('red');
          } else if ((row + col) % 4 === 1) {
            cell.classList.add('blue');
          } else if ((row + col) % 4 === 2) {
            cell.classList.add('green');
          } else if ((row + col) % 4 === 3) {
            cell.classList.add('yellow');
          } else {
            cell.classList.add('white');
          }
          
          cell.textContent = cellNumber;
          cell.id = `cell-${cellNumber}`;
          board.appendChild(cell);
        }
      }
      
      // Draw chutes and ladders
      drawChutesAndLadders();
    }
    
    // Generate the edit board
    function createEditBoard() {
      const board = document.getElementById('edit-board');
      board.innerHTML = '';
      
      // Create a 10x10 grid with numbers 1 to 100, starting from bottom-left
      let cellNumber = 1;
      for (let row = 9; row >= 0; row--) {
        const rowStart = row * 10 + 1;
        const rowEnd = (row + 1) * 10;
        
        for (let col = 0; col < 10; col++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          
          // Assign cell number based on row (snake pattern)
          if (row % 2 === 0) { // Even rows (left to right)
            cellNumber = rowStart + col;
          } else { // Odd rows (right to left)
            cellNumber = rowEnd - col;
          }
          
          // Set cell color based on the board image
          if ((row + col) % 4 === 0) {
            cell.classList.add('red');
          } else if ((row + col) % 4 === 1) {
            cell.classList.add('blue');
          } else if ((row + col) % 4 === 2) {
            cell.classList.add('green');
          } else if ((row + col) % 4 === 3) {
            cell.classList.add('yellow');
          } else {
            cell.classList.add('white');
          }
          
          cell.textContent = cellNumber;
          cell.id = `edit-cell-${cellNumber}`;
          
          // Add click event for editing
          cell.addEventListener('click', () => handleCellClick(cellNumber));
          
          board.appendChild(cell);
        }
      }
      
      // Draw chutes and ladders in edit mode
      drawChutesAndLadders('edit-board');
    }

    function drawChutesAndLadders(boardId = 'board') {
      // Get the board container
      const boardContainer = boardId === 'board' ? 
        document.querySelector('.board-container') : 
        document.querySelectorAll('.board-container')[1];
      
      // Clear any existing chutes/ladders
      const existingSvgs = boardContainer.querySelectorAll('svg');
      existingSvgs.forEach(svg => svg.remove());
      
      // Draw each ladder and chute as SVG lines
      for (const [start, end] of Object.entries(transitions)) {
        if (parseInt(end) > parseInt(start)) {
          // It's a ladder (goes up)
          drawLadder(parseInt(start), parseInt(end), boardId);
        } else {
          // It's a chute (goes down)
          drawChute(parseInt(start), parseInt(end), boardId);
        }
      }
    }
    
    function drawLadder(start, end, boardId = 'board') {
      const cellPrefix = boardId === 'board' ? 'cell' : 'edit-cell';
      const startCell = document.getElementById(`${cellPrefix}-${start}`);
      const endCell = document.getElementById(`${cellPrefix}-${end}`);
      
      if (!startCell || !endCell) return;
      
      const boardContainer = boardId === 'board' ? 
        document.querySelector('.board-container') : 
        document.querySelectorAll('.board-container')[1];
      
      const boardRect = boardContainer.querySelector('.board').getBoundingClientRect();
      const startRect = startCell.getBoundingClientRect();
      const endRect = endCell.getBoundingClientRect();
      
      // Calculate relative positions
      const startX = startRect.left - boardRect.left + startRect.width / 2;
      const startY = startRect.top - boardRect.top + startRect.height / 2;
      const endX = endRect.left - boardRect.left + endRect.width / 2;
      const endY = endRect.top - boardRect.top + endRect.height / 2;
      
      // Create SVG for ladder
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('width', '100%');
      svg.setAttribute('height', '100%');
      svg.style.position = 'absolute';
      svg.style.top = '0';
      svg.style.left = '0';
      svg.style.pointerEvents = 'none';
      svg.dataset.from = start;
      svg.dataset.to = end;
      svg.dataset.type = 'ladder';
      
      // Create main ladder line
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', startX);
      line.setAttribute('y1', startY);
      line.setAttribute('x2', endX);
      line.setAttribute('y2', endY);
      line.setAttribute('stroke', 'green');
      line.setAttribute('stroke-width', '4');
      
      svg.appendChild(line);
      boardContainer.appendChild(svg);
    }
    
    function drawChute(start, end, boardId = 'board') {
      const cellPrefix = boardId === 'board' ? 'cell' : 'edit-cell';
      const startCell = document.getElementById(`${cellPrefix}-${start}`);
      const endCell = document.getElementById(`${cellPrefix}-${end}`);
      
      if (!startCell || !endCell) return;
      
      const boardContainer = boardId === 'board' ? 
        document.querySelector('.board-container') : 
        document.querySelectorAll('.board-container')[1];
      
      const boardRect = boardContainer.querySelector('.board').getBoundingClientRect();
      const startRect = startCell.getBoundingClientRect();
      const endRect = endCell.getBoundingClientRect();
      
      // Calculate relative positions
      const startX = startRect.left - boardRect.left + startRect.width / 2;
      const startY = startRect.top - boardRect.top + startRect.height / 2;
      const endX = endRect.left - boardRect.left + endRect.width / 2;
      const endY = endRect.top - boardRect.top + endRect.height / 2;
      
      // Create SVG for chute
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('width', '100%');
      svg.setAttribute('height', '100%');
      svg.style.position = 'absolute';
      svg.style.top = '0';
      svg.style.left = '0';
      svg.style.pointerEvents = 'none';
      svg.dataset.from = start;
      svg.dataset.to = end;
      svg.dataset.type = 'chute';
      
      // Create curvy path for the chute
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      const midX = (startX + endX) / 2;
      const ctrlX = (startX + midX) / 2;
      const ctrlY = (startY + endY) / 2;
      
      const d = `M ${startX} ${startY} Q ${ctrlX} ${ctrlY}, ${endX} ${endY}`;
      
      path.setAttribute('d', d);
      path.setAttribute('stroke', 'red');
      path.setAttribute('stroke-width', '4');
      path.setAttribute('fill', 'none');
      
      svg.appendChild(path);
      boardContainer.appendChild(svg);
    }
    
    // Roll the dice
    function rollDice() {
      if (isMoving) return;
      
      const diceElement = document.getElementById('dice');
      const rollButton = document.getElementById('rollButton');
      
      // Disable roll button while moving
      rollButton.disabled = true;
      
      // Animate dice rolling
      let rollCount = 0;
      const maxRolls = 10;
      const rollInterval = setInterval(() => {
        const randomRoll = Math.floor(Math.random() * 6) + 1;
        diceElement.textContent = randomRoll;
        
        rollCount++;
        if (rollCount >= maxRolls) {
          clearInterval(rollInterval);
          const finalRoll = Math.floor(Math.random() * 6) + 1;
          diceElement.textContent = finalRoll;
          movePlayer(finalRoll);
        }
      }, 100);
    }
    
    // Move the player on the board
    function movePlayer(steps) {
      isMoving = true;
      const player = document.getElementById('player');
      const gameInfo = document.getElementById('gameInfo');
      
      // Calculate new position
      const newPosition = Math.min(currentPosition + steps, 100);
      
      // Move step by step
      let currentStep = currentPosition;
      const moveInterval = setInterval(() => {
        if (currentStep < newPosition) {
          currentStep++;
          updatePlayerPosition(currentStep);
          gameInfo.textContent = `Moving to ${currentStep}...`;
        } else {
          clearInterval(moveInterval);
          
          // Check for chutes or ladders
          if (transitions[newPosition]) {
            setTimeout(() => {
              const destinationPosition = transitions[newPosition];
              
              if (destinationPosition > newPosition) {
                gameInfo.textContent = `Yay! Climbing ladder from ${newPosition} to ${destinationPosition}`;
              } else {
                gameInfo.textContent = `Oops! Sliding down chute from ${newPosition} to ${destinationPosition}`;
              }
              
              setTimeout(() => {
                updatePlayerPosition(destinationPosition);
                currentPosition = destinationPosition;
                
                // Check for win
                checkWinCondition();
                
                // Re-enable roll button
                document.getElementById('rollButton').disabled = false;
                isMoving = false;
              }, 1000);
            }, 500);
          } else {
            currentPosition = newPosition;
            gameInfo.textContent = `You are now at position ${currentPosition}`;
            
            // Check for win
            checkWinCondition();
            
            // Re-enable roll button
            document.getElementById('rollButton').disabled = false;
            isMoving = false;
          }
        }
      }, 300);
    }
    
    // Update player position on the board
    function updatePlayerPosition(position) {
      const player = document.getElementById('player');
      
      if (position > 0) {
        const cell = document.getElementById(`cell-${position}`);
        if (cell) {
          const cellRect = cell.getBoundingClientRect();
          const boardRect = document.querySelector('.board-container').getBoundingClientRect();
          
          const top = cellRect.top - boardRect.top + (cellRect.height / 2) - 10;
          const left = cellRect.left - boardRect.left + (cellRect.width / 2) - 10;
          
          player.style.top = `${top}px`;
          player.style.left = `${left}px`;
        }
      } else {
        // Position 0 (start position)
        player.style.top = `${500-30}px`; // Bottom of the board
        player.style.left = '-35px'; // Left side
      }
    }
    
    // Check win condition
    function checkWinCondition() {
      if (currentPosition >= 100) {
        setTimeout(() => {
          document.getElementById('winModal').style.display = 'flex';
        }, 500);
      }
    }
    
    // Reset the game
    function resetGame() {
      currentPosition = 0;
      isMoving = false;
      document.getElementById('dice').textContent = '?';
      document.getElementById('gameInfo').textContent = 'Start at position 0. Roll to begin!';
      document.getElementById('rollButton').disabled = false;
      document.getElementById('winModal').style.display = 'none';
      updatePlayerPosition(0);
    }
    
    // EDIT MODE FUNCTIONS
    
    function handleCellClick(cellNumber) {
      // Highlight the selected cell
      const cell = document.getElementById(`edit-cell-${cellNumber}`);
      
      // If this cell is already selected, unselect it
      if (selectedCells.includes(cellNumber)) {
        selectedCells = selectedCells.filter(num => num !== cellNumber);
        cell.classList.remove('highlight');
        updateEditInfo();
        return;
      }
      
      // Add the cell to selected cells
      selectedCells.push(cellNumber);
      cell.classList.add('highlight');
      
      // If we have 2 selected cells, create a transition
      if (selectedCells.length === 2) {
        createTransition();
      }
      
      updateEditInfo();
    }
    function createTransition() {
  const [first, second] = selectedCells;
  
  // Check if it's valid
  if (first === second) {
    alert("Can't create a transition to the same square");
    resetSelection();
    return;
  }
  
  // Check if we already have a transition from either cell
  if (transitions[first] !== undefined) {
    delete transitions[first];
  }
  
  // Add the transition based on the mode
  if (editMode === "ladder") {
    // Ladders go up, so start should be lower than end
    if (first < second) {
      transitions[first] = second;
    } else {
      transitions[second] = first;
    }
  } else if (editMode === "chute") {
    // Chutes go down, so start should be higher than end
    if (first > second) {
      transitions[first] = second;
    } else {
      transitions[second] = first;
    }
  }
  
  // Redraw all chutes and ladders
  drawChutesAndLadders('edit-board');
  updateTransitionList();
  
  // Reset selection after creating transition
  resetSelection();
  
  // Update transition stats
  updateTransitionStats();
}
    
    function resetSelection() {
      // Clear highlighting
      selectedCells.forEach(cellNum => {
        const cell = document.getElementById(`edit-cell-${cellNum}`);
        if (cell) cell.classList.remove('highlight');
      });
      
      // Clear selected cells
      selectedCells = [];
      updateEditInfo();
    }
    
    // function updateEditInfo() {
    //   const infoElement = document.getElementById('edit-info');
      
    //   if (selectedCells.length === 0) {
    //     infoElement.textContent = 'Click on two cells to create a connection';
    //   } else if (selectedCells.length === 1) {
    //     infoElement.textContent = `Selected: ${selectedCells[0]}. Click another cell to create a ${editMode}`;
    //   }
    // }
    
    function updateTransitionList() {
      const listElement = document.getElementById('transition-list');
      listElement.innerHTML = '';
      
      // Sort transitions by start position
      const sortedTransitions = Object.entries(transitions).sort((a, b) => parseInt(a[0]) - parseInt(b[0]));
      
      for (const [start, end] of sortedTransitions) {
        const item = document.createElement('div');
        item.className = 'transition-item';
        
        // Determine if it's a ladder or chute
        const type = parseInt(end) > parseInt(start) ? 'Ladder' : 'Chute';
        
        item.innerHTML = `
          <span>${type}: ${start} → ${end}</span>
          <button class="delete-transition" data-start="${start}">×</button>
        `;
        
        listElement.appendChild(item);
      }
      
      // Add delete event listeners
      document.querySelectorAll('.delete-transition').forEach(button => {
        button.addEventListener('click', (e) => {
          const start = e.target.getAttribute('data-start');
          delete transitions[start];
          drawChutesAndLadders('edit-board');
          updateTransitionList();
          updateTransitionStats();
        });
      });
    }
    
    function updateTransitionStats() {
      const ladders = [];
      const chutes = [];
      
      // Categorize transitions
      for (const [start, end] of Object.entries(transitions)) {
        const startNum = parseInt(start);
        const endNum = parseInt(end);
        
        if (endNum > startNum) {
          ladders.push({ start: startNum, end: endNum, change: endNum - startNum });
        } else {
          chutes.push({ start: startNum, end: endNum, change: startNum - endNum });
        }
      }
      
      // Calculate stats
      const avgLadderClimb = ladders.length > 0 ? 
        ladders.reduce((sum, l) => sum + l.change, 0) / ladders.length : 0;
      
      const avgChuteFall = chutes.length > 0 ? 
        chutes.reduce((sum, c) => sum + c.change, 0) / chutes.length : 0;
      
      // Update UI
      document.getElementById('transitions-count').textContent = 
        `Number of ladders: ${ladders.length}, Number of chutes: ${chutes.length}`;
      
      document.getElementById('transition-stats').textContent = 
        `Average ladder climb: ${avgLadderClimb.toFixed(1)}, Average chute fall: ${avgChuteFall.toFixed(1)}`;
    }
    
    function exportTransitions() {
      const textArea = document.getElementById('import-export-json');
      textArea.value = JSON.stringify(transitions, null, 2);
    }
    
    function importTransitions() {
      const textArea = document.getElementById('import-export-json');
      
      try {
        const importedData = JSON.parse(textArea.value);
        
        // Validate the data
        let isValid = true;
        for (const [start, end] of Object.entries(importedData)) {
          if (isNaN(parseInt(start)) || isNaN(parseInt(end))) {
            isValid = false;
            break;
          }
        }
        
        if (isValid) {
          transitions = importedData;
          drawChutesAndLadders('edit-board');
          updateTransitionList();
          updateTransitionStats();
          alert('Board configuration imported successfully');
        } else {
          alert('Invalid JSON format. Please check your data.');
        }
      } catch (error) {
        alert('Invalid JSON. Please check your format.');
        console.error(error);
      }
    }
    
    // SIMULATION AND STATISTICS FUNCTIONS
    
    function simulateGame() {
      let moves = 0;
      let position = 0;
      
      while (position < 100 && moves < 1000) { // Prevent infinite loops
        moves++;
        
        // Roll dice
        const roll = Math.floor(Math.random() * 6) + 1;
        position = Math.min(position + roll, 100);
        
        // Check for chutes/ladders
        if (position < 100 && transitions[position]) {
          position = transitions[position];
        }
      }
      
      return moves;
    }
    
    function runSimulations(count = 10000) {
      const results = [];
      
      // Run the simulations
      for (let i = 0; i < count; i++) {
        results.push(simulateGame());
      }
      
      // Calculate statistics
      const sum = results.reduce((acc, val) => acc + val, 0);
      const mean = sum / results.length;
      
      // Calculate standard deviation
      const squaredDiffs = results.map(x => Math.pow(x - mean, 2));
      const variance = squaredDiffs.reduce((acc, val) => acc + val, 0) / results.length;
      const stdDev = Math.sqrt(variance);
      
      // Calculate median
      const sortedResults = [...results].sort((a, b) => a - b);
      const median = sortedResults[Math.floor(results.length / 2)];
      
      // Update UI
      document.getElementById('expected-moves').textContent = `Expected number of moves: ${mean.toFixed(2)}`;
      document.getElementById('median-moves').textContent = `Median number of moves: ${median}`;
      document.getElementById('std-dev-moves').textContent = `Standard deviation of moves: ${stdDev.toFixed(2)}`;
      
      // Create histogram data
      const histogramData = {};
      const binSize = 5;
      const maxBin = Math.ceil(Math.max(...results) / binSize) * binSize;
      
      for (let i = 0; i <= maxBin; i += binSize) {
        histogramData[i] = 0;
      }
      
      results.forEach(result => {
        const bin = Math.floor(result / binSize) * binSize;
        histogramData[bin]++;
      });
      
      // Draw histogram
      drawHistogram(histogramData, count);
    }
    
    function drawHistogram(data, totalCount) {
      const canvas = document.getElementById('moves-histogram');
      const ctx = canvas.getContext('2d');
      
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Set up dimensions
      const width = canvas.width;
      const height = canvas.height;
      const padding = { top: 40, right: 20, bottom: 30, left: 40 };  // Increase top padding
      const chartWidth = width - padding.left - padding.right;
      const chartHeight = height - padding.top - padding.bottom;
      
      // Find max value for scaling
      const maxValue = Math.max(...Object.values(data));
    const maxFrequency = Math.max(Math.ceil(maxValue / totalCount * 100), 1); // Ensure maxFrequency is at least 1

      
      // Sort bins
      const sortedBins = Object.keys(data).map(bin => parseInt(bin)).sort((a, b) => a - b);
      
      // Calculate bar width
      // Aggregate bins (combine every 3 bins into one)
const aggregatedBins = [];
for (let i = 0; i < sortedBins.length; i += 3) {
  const binGroup = sortedBins.slice(i, i + 3);
  const aggregatedValue = binGroup.reduce((sum, bin) => sum + data[bin], 0);
  const aggregatedBin = Math.floor((binGroup[0] + binGroup[binGroup.length - 1]) / 2); // Use the middle bin as the new "bin"
  aggregatedBins.push({ bin: aggregatedBin, value: aggregatedValue });
}

// Calculate bar width based on aggregated bins
const barWidth = chartWidth / aggregatedBins.length;

      
      // Draw axes
      ctx.beginPath();
      ctx.moveTo(padding.left, padding.top);
      ctx.lineTo(padding.left, height - padding.bottom);
      ctx.lineTo(width - padding.right, height - padding.bottom);
      ctx.stroke();
      
      // Draw bars
      // Draw bars
// Draw bars
// Calculate max percentage
const maxPercentage = Math.max(...aggregatedBins.map(binData => (binData.value / totalCount) * 100));

// Draw bars
aggregatedBins.forEach((binData, index) => {
  const value = binData.value;
  const percentage = (value / totalCount) * 100;  // Percentage calculation
  const barHeight = (percentage / ( maxPercentage + 5 )) * chartHeight;  // Scale bar height based on maxPercentage
  
  const x = padding.left + index * barWidth;
  const y = height - padding.bottom - barHeight;
  
  // Draw bar
  ctx.fillStyle = 'rgba(75, 192, 192, 0.7)';
  ctx.fillRect(x, y, barWidth - 2, barHeight);

  // Draw bin label
  ctx.fillStyle = 'black';
  ctx.textAlign = 'center';
  ctx.fillText(binData.bin, x + barWidth / 2, height - padding.bottom + 15);
  
  // Draw value on top of bar if it's significant
  if (percentage > 2) {
    ctx.fillStyle = 'black';
    ctx.textAlign = 'center';
    ctx.fillText(`${percentage.toFixed(1)}%`, x + barWidth / 2, Math.max(y - 5, padding.top + 5)); // Ensure text is within canvas
  }
});
      
      // Draw y-axis labels
      ctx.fillStyle = 'black';
      ctx.textAlign = 'right';
      
      for (let i = 0; i <= maxFrequency; i += 5) {
        const y = height - padding.bottom - (i / maxFrequency) * chartHeight;
        // ctx.fillText(`${i}%`, padding.left - 5, y + 3);
        
        // Draw gridline
        ctx.beginPath();
        ctx.strokeStyle = '#ddd';
        ctx.moveTo(padding.left, y);
        ctx.lineTo(width - padding.right, y);
        ctx.stroke();
      }
      
      // Draw x-axis title
      ctx.textAlign = 'center';
      ctx.fillText('Number of Moves', width / 2, height - 5);
      
      // Draw y-axis title
      ctx.save();
      ctx.translate(15, height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.textAlign = 'center';
      ctx.fillText('Frequency (%)', 0, 0);
      ctx.restore();
    }
    
    // EVENT LISTENERS
    
    function setupEventListeners() {
      // Game tab events
      document.getElementById('rollButton').addEventListener('click', rollDice);
      document.getElementById('newGameButton').addEventListener('click', resetGame);
      
      // Edit tab events
      document.getElementById('add-ladder-button').addEventListener('click', () => {
        editMode = "ladder";
        document.getElementById('add-ladder-button').classList.add('active');
        document.getElementById('add-chute-button').classList.remove('active');
      });
      
      document.getElementById('add-chute-button').addEventListener('click', () => {
        editMode = "chute";
        document.getElementById('add-ladder-button').classList.remove('active');
        document.getElementById('add-chute-button').classList.add('active');
      });
      
      document.getElementById('reset-selection-button').addEventListener('click', resetSelection);
      
      document.getElementById('reset-board-button').addEventListener('click', () => {
        transitions = JSON.parse(JSON.stringify(defaultTransitions));
        drawChutesAndLadders('edit-board');
        updateTransitionList();
        updateTransitionStats();
      });
      
      document.getElementById('export-button').addEventListener('click', exportTransitions);
      document.getElementById('import-button').addEventListener('click', importTransitions);
      
      // Stats tab events
      document.getElementById('runSimulationButton').addEventListener('click', () => {
        document.getElementById('runSimulationButton').disabled = true;
        document.getElementById('runSimulationButton').textContent = 'Running...';
        
        // Use setTimeout to allow UI to update before running the simulation
        setTimeout(() => {
          runSimulations(10000);
          document.getElementById('runSimulationButton').disabled = false;
          document.getElementById('runSimulationButton').textContent = 'Run 10,000 Simulations';
        }, 10);
      });
    }
    
    // INITIALIZE THE GAME
    
    function init() {
      setupTabs();
      createBoard();
      createEditBoard();
      setupEventListeners();
      updatePlayerPosition(currentPosition);
      updateTransitionList();
      updateTransitionStats();
    }
    
    // Run init when DOM is loaded
    document.addEventListener('DOMContentLoaded', init);
  </script>

  <p><p>&copy; 2025 Gary Hu</p>
</body>
</html>